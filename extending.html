

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. Extending PyMC &mdash; PyMC 2.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://mathjax.connectmv.com/MathJax.js?config=default"></script>
    <link rel="top" title="PyMC 2.2 documentation" href="index.html" />
    <link rel="next" title="9. Probability distributions" href="distributions.html" />
    <link rel="prev" title="7. Model checking and diagnostics" href="modelchecking.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="distributions.html" title="9. Probability distributions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modelchecking.html" title="7. Model checking and diagnostics"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyMC 2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="extending-pymc">
<span id="chap-extending"></span><h1>8. Extending PyMC<a class="headerlink" href="#extending-pymc" title="Permalink to this headline">¶</a></h1>
<p>PyMC tries to make standard things easy, but keep unusual things possible. Its
openness, combined with Python&#8217;s flexibility, invite extensions from using new
step methods to exotic stochastic processes (see the Gaussian process module).
This chapter briefly reviews the ways PyMC is designed to be extended.</p>
<div class="section" id="nonstandard-stochastics">
<span id="nonstandard"></span><h2>8.1. Nonstandard Stochastics<a class="headerlink" href="#nonstandard-stochastics" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to create a <tt class="docutils literal"><span class="pre">Stochastic</span></tt> object with a nonstandard
distribution is to use the medium or long decorator syntax. See Chapter
<a class="reference internal" href="modelbuilding.html#chap-modelbuilding"><em>Building models</em></a>. If you want to create many stochastics with the same
nonstandard distribution, the decorator syntax can become cumbersome. An actual
subclass of <tt class="docutils literal"><span class="pre">Stochastic</span></tt> can be created using the class factory
<tt class="docutils literal"><span class="pre">stochastic_from_dist</span></tt>. This function takes the following arguments:</p>
<blockquote>
<div><ul class="simple">
<li>The name of the new class,</li>
<li>A <tt class="docutils literal"><span class="pre">logp</span></tt> function,</li>
<li>A <tt class="docutils literal"><span class="pre">random</span></tt> function,</li>
<li>The NumPy datatype of the new class (for continuous distributions, this
should be <tt class="docutils literal"><span class="pre">float</span></tt>; for discrete distributions, <tt class="docutils literal"><span class="pre">int</span></tt>; for variables
valued as non-numerical objects, <tt class="docutils literal"><span class="pre">object</span></tt>),</li>
<li>A flag indicating whether the resulting class represents a vector-valued
variable.</li>
</ul>
</div></blockquote>
<p>The necessary parent labels are read from the <tt class="docutils literal"><span class="pre">logp</span></tt> function, and a
docstring for the new class is automatically generated. Instances of the new
class can be created in one line.</p>
<p>Full subclasses of <tt class="docutils literal"><span class="pre">Stochastic</span></tt> may be necessary to provide nonstandard
behaviors (see <tt class="docutils literal"><span class="pre">gp.GP</span></tt>).</p>
</div>
<div class="section" id="user-defined-step-methods">
<span id="custom-stepper"></span><h2>8.2. User-defined step methods<a class="headerlink" href="#user-defined-step-methods" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">StepMethod</span></tt> class is meant to be subclassed. There are an enormous number of MCMC step methods in the literature, whereas PyMC provides only about half a dozen. Most user-defined step methods will be either Metropolis-Hastings or Gibbs step methods, and these should subclass <tt class="docutils literal"><span class="pre">Metropolis</span></tt> or <tt class="docutils literal"><span class="pre">Gibbs</span></tt> respectively. More unusual step methods should subclass <tt class="docutils literal"><span class="pre">StepMethod</span></tt> directly.</p>
<div class="section" id="example-an-asymmetric-metropolis-step">
<h3>8.2.1. Example: an asymmetric Metropolis step<a class="headerlink" href="#example-an-asymmetric-metropolis-step" title="Permalink to this headline">¶</a></h3>
<p>Consider the probability model in <tt class="file docutils literal"><span class="pre">examples/custom_step.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mu</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s">&#39;mu&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">.</span><span class="mo">01</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">tau</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="s">&#39;tau&#39;</span><span class="p">,</span><span class="o">.</span><span class="mo">01</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cutoff</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="s">&#39;cutoff&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.3</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Truncnorm</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">,</span><span class="n">mu</span><span class="p">,</span><span class="n">tau</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">cutoff</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">observed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The stochastic variable <tt class="docutils literal"><span class="pre">cutoff</span></tt> cannot be smaller than the largest element
of <span class="math">\(D\)</span>, otherwise <span class="math">\(D\)</span>&#8216;s density would be zero. The standard
<tt class="docutils literal"><span class="pre">Metropolis</span></tt> step method can handle this case without problems; it will
propose illegal values occasionally, but these will be rejected.</p>
<p>Suppose we want to handle <tt class="docutils literal"><span class="pre">cutoff</span></tt> with a smarter step method that doesn&#8217;t
propose illegal values. Specifically, we want to use the nonsymmetric proposal
distribution:</p>
<div class="math">
\[\begin{eqnarray*}
      x_p | x \sim \textup{Truncnorm}(x, \sigma, \max(D), \infty).
\end{eqnarray*}\]</div><p>We can implement this Metropolis-Hastings algorithm with the following step method class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TruncatedMetropolis</span><span class="p">(</span><span class="n">pymc</span><span class="o">.</span><span class="n">Metropolis</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stochastic</span><span class="p">,</span> <span class="n">low_bound</span><span class="p">,</span> <span class="n">up_bound</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_bound</span> <span class="o">=</span> <span class="n">low_bound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up_bound</span> <span class="o">=</span> <span class="n">up_bound</span>
        <span class="n">pymc</span><span class="o">.</span><span class="n">Metropolis</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stochastic</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">propose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adaptive_scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_sd</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> \
        <span class="n">pymc</span><span class="o">.</span><span class="n">rtruncnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_bound</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hastings_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adaptive_scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_sd</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">cur_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">value</span>
        <span class="n">last_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">last_value</span>

        <span class="n">lp_for</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">truncnorm_like</span><span class="p">(</span><span class="n">cur_val</span><span class="p">,</span> <span class="n">last_val</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_bound</span><span class="p">)</span>
        <span class="n">lp_bak</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">truncnorm_like</span><span class="p">(</span><span class="n">last_val</span><span class="p">,</span> <span class="n">cur_val</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_bound</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">+</span> <span class="s">&#39;: Hastings factor </span><span class="si">%f</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">lp_bak</span> <span class="o">-</span> <span class="n">lp_for</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lp_bak</span> <span class="o">-</span> <span class="n">lp_for</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">propose</span></tt> method sets the step method&#8217;s stochastic&#8217;s value to a new
value, drawn from a truncated normal distribution. The precision of this
distribution is computed from two factors: <tt class="docutils literal"><span class="pre">self.proposal_sd</span></tt>, which can be
set with an input argument to Metropolis, and <tt class="docutils literal"><span class="pre">self.adaptive_scale_factor</span></tt>.
Metropolis step methods&#8217; default tuning behavior is to reduce
<tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt> if the acceptance rate is too low, and to increase
<tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt> if it is too high. By incorporating
<tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt> into the proposal standard deviation, we avoid having
to write our own tuning infrastructure. If we don&#8217;t want the proposal to tune,
we don&#8217;t have to use <tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">hastings_factor</span></tt> method adjusts for the asymmetric proposal distribution
<a class="reference internal" href="references.html#gelman2004">[Gelman2004]</a>. It computes the log of the quotient of the &#8216;backward&#8217; density
and the &#8216;forward&#8217; density. For symmetric proposal distributions, this quotient
is 1, so its log is zero.</p>
<p>Having created our custom step method, we need to tell MCMC instances to use it
to handle the variable <tt class="docutils literal"><span class="pre">cutoff</span></tt>. This is done in <tt class="file docutils literal"><span class="pre">custom_step.py</span></tt> with
the following line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">M</span><span class="o">.</span><span class="n">use_step_method</span><span class="p">(</span><span class="n">TruncatedMetropolis</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
</pre></div>
</div>
<p>This call causes <span class="math">\(M\)</span> to pass the arguments <tt class="docutils literal"><span class="pre">cutoff</span></tt>, <tt class="docutils literal"><span class="pre">D.value.max()</span></tt>,
and <tt class="docutils literal"><span class="pre">np.inf</span></tt> to a <tt class="docutils literal"><span class="pre">TruncatedMetropolis</span></tt> object&#8217;s <tt class="docutils literal"><span class="pre">__init__</span></tt> method, and
use the object to handle <tt class="docutils literal"><span class="pre">cutoff</span></tt>.</p>
<p>Its often convenient to get a handle to a custom step method instance directly
for debugging purposes. <tt class="docutils literal"><span class="pre">M.step_method_dict[cutoff]</span></tt> returns a list of all
the step methods <span class="math">\(M\)</span> will use to handle <tt class="docutils literal"><span class="pre">cutoff</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">step_method_dict</span><span class="p">[</span><span class="n">cutoff</span><span class="p">]</span>
<span class="go">[&lt;custom_step.TruncatedMetropolis object at 0x3c91130&gt;]</span>
</pre></div>
</div>
<p>There may be more than one, and conversely step methods may handle more than
one stochastic variable. To see which variables step method <span class="math">\(S\)</span> is
handling, try:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">stochastics</span>
<span class="go">set([&lt;pymc.distributions.Exponential &#39;cutoff&#39; at 0x3cd6b90&gt;])</span>
</pre></div>
</div>
</div>
<div class="section" id="general-step-methods">
<h3>8.2.2. General step methods<a class="headerlink" href="#general-step-methods" title="Permalink to this headline">¶</a></h3>
<p>All step methods must implement the following methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">step()</span></tt>:</dt>
<dd>Updates the values of <tt class="docutils literal"><span class="pre">self.stochastics</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">tune()</span></tt>:</dt>
<dd><p class="first">Tunes the jumping strategy based on performance so far. A default method is
available that increases <tt class="docutils literal"><span class="pre">self.adaptive_scale_factor</span></tt> (see below) when
acceptance rate is high, and decreases it when acceptance rate is low. This
method should return <tt class="docutils literal"><span class="pre">True</span></tt> if additional tuning will be required later,</p>
<blockquote class="last">
<div>and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</div></blockquote>
</dd>
<dt><tt class="docutils literal"><span class="pre">competence(s):</span></tt></dt>
<dd><dl class="first docutils">
<dt>A class method that examines stochastic variable <span class="math">\(s\)</span> and returns a</dt>
<dd>value from 0 to 3 expressing the step method&#8217;s ability to handle the
variable. This method is used by <tt class="docutils literal"><span class="pre">MCMC</span></tt> instances when automatically
assigning step methods. Conventions are:</dd>
<dt>0</dt>
<dd>I cannot safely handle this variable.</dd>
<dt>1</dt>
<dd>I can handle the variable about as well as the standard <tt class="docutils literal"><span class="pre">Metropolis</span></tt> step method.</dd>
<dt>2</dt>
<dd>I can do better than <tt class="docutils literal"><span class="pre">Metropolis</span></tt>.</dd>
<dt>3</dt>
<dd>I am the best step method you are likely to find for this variable in most cases.</dd>
</dl>
<p>For example, if you write a step method that can handle
<tt class="docutils literal"><span class="pre">MyStochasticSubclass</span></tt> well, the competence method might look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyStepMethod</span><span class="p">(</span><span class="n">pymc</span><span class="o">.</span><span class="n">StepMethod</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stochastic</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="o">...</span>

   <span class="nd">@classmethod</span>
   <span class="k">def</span> <span class="nf">competence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stochastic</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stochastic</span><span class="p">,</span> <span class="n">MyStochasticSubclass</span><span class="p">):</span>
         <span class="k">return</span> <span class="mi">3</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p class="last">Note that PyMC will not even attempt to assign a step method automatically
if its <tt class="docutils literal"><span class="pre">__init__</span></tt> method cannot be called with a single stochastic
instance, that is <tt class="docutils literal"><span class="pre">MyStepMethod(x)</span></tt> is a legal call. The list of step
methods that PyMC will consider assigning automatically is called
<tt class="docutils literal"><span class="pre">pymc.StepMethodRegistry</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">current_state()</span></tt>:</dt>
<dd><p class="first">This method is easiest to explain by showing the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">state</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">:</span>
    <span class="n">state</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="k">return</span> <span class="n">state</span>
</pre></div>
</div>
<p class="last"><tt class="docutils literal"><span class="pre">self._state</span></tt> should be a list containing the names of the attributes
needed to reproduce the current jumping strategy. If an <tt class="docutils literal"><span class="pre">MCMC</span></tt> object
writes its state out to a database, these attributes will be preserved. If
an <tt class="docutils literal"><span class="pre">MCMC</span></tt> object restores its state from the database later, the
corresponding step method will have these attributes set to their saved
values.</p>
</dd>
</dl>
<p>Step methods should also maintain the following attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">_id</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>A string that can identify each step method uniquely (usually something</dt>
<dd>like <tt class="docutils literal"><span class="pre">&lt;class_name&gt;_&lt;stochastic_name&gt;</span></tt>).</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt>:</dt>
<dd>An &#8216;adaptive scale factor&#8217;. This attribute is only needed if the default
<tt class="docutils literal"><span class="pre">tune()</span></tt> method is used.</dd>
<dt><tt class="docutils literal"><span class="pre">_tuning_info</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>A list of strings giving the names of any tuning parameters. For</dt>
<dd><tt class="docutils literal"><span class="pre">Metropolis</span></tt> instances, this would be <tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt>. This
list is used to keep traces of tuning parameters in order to verify
&#8216;diminishing tuning&#8217; <a class="reference internal" href="references.html#roberts2007">[Roberts2007]</a>.</dd>
</dl>
</dd>
</dl>
<p>All step methods have a property called <tt class="docutils literal"><span class="pre">loglike</span></tt>, which returns the sum of
the log-probabilities of the union of the extended children of
<tt class="docutils literal"><span class="pre">self.stochastics</span></tt>. This quantity is one term in the log of the Metropolis-
Hastings acceptance ratio. The <tt class="docutils literal"><span class="pre">logp_plus_loglike</span></tt> property gives the sum of
that and the log-probabilities of <tt class="docutils literal"><span class="pre">self.stochastics</span></tt>.</p>
</div>
<div class="section" id="metropolis-hastings-step-methods">
<span id="user-metro"></span><h3>8.2.3. Metropolis-Hastings step methods<a class="headerlink" href="#metropolis-hastings-step-methods" title="Permalink to this headline">¶</a></h3>
<p>A Metropolis-Hastings step method only needs to implement the following
methods, which are called by <tt class="docutils literal"><span class="pre">Metropolis.step()</span></tt>:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">reject()</span></tt>:</dt>
<dd><p class="first">Usually just</p>
<div class="last highlight-python"><pre>def reject(self):
    self.rejected += 1
    [s.value = s.last_value for s in self.stochastics]</pre>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">propose():</span></tt></dt>
<dd>Sets the values of all <tt class="docutils literal"><span class="pre">self.stochastics</span></tt> to new, proposed values. This
method may use the <tt class="docutils literal"><span class="pre">adaptive_scale_factor</span></tt> attribute to take advantage of
the standard tuning scheme.</dd>
</dl>
<p>Metropolis-Hastings step methods may also override the <tt class="docutils literal"><span class="pre">tune</span></tt> and <tt class="docutils literal"><span class="pre">competence</span></tt> methods.</p>
<p>Metropolis-Hastings step methods with asymmetric jumping distributions may
implement a method called <tt class="docutils literal"><span class="pre">hastings_factor()</span></tt>, which returns the log of the
ratio of the &#8216;reverse&#8217; and &#8216;forward&#8217; proposal probabilities. Note that no
<tt class="docutils literal"><span class="pre">accept()</span></tt> method is needed or used.</p>
<p>By convention, Metropolis-Hastings step methods use attributes called
<tt class="docutils literal"><span class="pre">accepted</span></tt> and <tt class="docutils literal"><span class="pre">rejected</span></tt> to log their performance.</p>
</div>
<div class="section" id="gibbs-step-methods">
<span id="user-gibbs"></span><h3>8.2.4. Gibbs step methods<a class="headerlink" href="#gibbs-step-methods" title="Permalink to this headline">¶</a></h3>
<p>Gibbs step methods handle conjugate submodels. These models usually have two
components: the &#8216;parent&#8217; and the &#8216;children&#8217;. For example, a gamma-distributed
variable serving as the precision of several normally-distributed variables is
a conjugate submodel; the gamma variable is the parent and the normal variables
are the children.</p>
<p>This section describes PyMC&#8217;s current scheme for Gibbs step methods, several of
which are in a semi-working state in the <em>sandbox</em> directory. It is meant to be
as generic as possible to minimize code duplication, but it is admittedly
complicated. Feel free to subclass <tt class="docutils literal"><span class="pre">StepMethod</span></tt> directly when writing Gibbs
step methods if you prefer.</p>
<p>Gibbs step methods that subclass PyMC&#8217;s <tt class="docutils literal"><span class="pre">Gibbs</span></tt> should define the following
class attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">child_class</span></tt>:</dt>
<dd>The class of the children in the submodels the step method can handle.</dd>
<dt><tt class="docutils literal"><span class="pre">parent_class</span></tt>:</dt>
<dd>The class of the parent.</dd>
<dt><tt class="docutils literal"><span class="pre">parent_label</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>The label the children would apply to the parent in a conjugate submodel.</dt>
<dd>In the gamma-normal example, this would be <tt class="docutils literal"><span class="pre">tau</span></tt>.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">linear_OK</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>A flag indicating whether the children can use linear combinations</dt>
<dd>involving the parent as their actual parent without destroying the
conjugacy.</dd>
</dl>
</dd>
</dl>
<p>A subclass of <tt class="docutils literal"><span class="pre">Gibbs</span></tt> that defines these attributes only needs to implement a
<tt class="docutils literal"><span class="pre">propose()</span></tt> method, which will be called by <tt class="docutils literal"><span class="pre">Gibbs.step()</span></tt>. The resulting
step method will be able to handle both conjugate and &#8216;non-conjugate&#8217; cases.
The conjugate case corresponds to an actual conjugate submodel. In the
non-conjugate case all the children are of the required class, but the parent
is not. In this case the parent&#8217;s value is proposed from the likelihood and
accepted based on its prior. The acceptance rate in the non-conjugate case will
be less than one.</p>
<p>The inherited class method <tt class="docutils literal"><span class="pre">Gibbs.competence</span></tt> will determine the new step
method&#8217;s ability to handle a variable <span class="math">\(x\)</span> by checking whether:</p>
<blockquote>
<div><ul class="simple">
<li>all <span class="math">\(x\)</span>&#8216;s children are of class <tt class="docutils literal"><span class="pre">child_class</span></tt>, and either apply
<tt class="docutils literal"><span class="pre">parent_label</span></tt> to <span class="math">\(x\)</span> directly or (if <tt class="docutils literal"><span class="pre">linear_OK=True</span></tt>) to a
<tt class="docutils literal"><span class="pre">LinearCombination</span></tt> object (chapter <a class="reference internal" href="modelbuilding.html#chap-modelbuilding"><em>Building models</em></a>), one of
whose parents contains <span class="math">\(x\)</span>.</li>
<li><span class="math">\(x\)</span> is of class <tt class="docutils literal"><span class="pre">parent_class</span></tt></li>
</ul>
</div></blockquote>
<p>If both conditions are met, <tt class="docutils literal"><span class="pre">pymc.conjugate_Gibbs_competence</span></tt> will be
returned. If only the first is met, <tt class="docutils literal"><span class="pre">pymc.nonconjugate_Gibbs_competence</span></tt> will
be returned.</p>
</div>
</div>
<div class="section" id="new-fitting-algorithms">
<span id="custom-model"></span><h2>8.3. New fitting algorithms<a class="headerlink" href="#new-fitting-algorithms" title="Permalink to this headline">¶</a></h2>
<p>PyMC provides a convenient platform for non-MCMC fitting algorithms in addition
to MCMC. All fitting algorithms should be implemented by subclasses of
<tt class="docutils literal"><span class="pre">Model</span></tt>. There are virtually no restrictions on fitting algorithms, but many
of <tt class="docutils literal"><span class="pre">Model</span></tt>&#8216;s behaviors may be useful. See Chapter <a class="reference internal" href="modelfitting.html#chap-modelfitting"><em>Fitting Models</em></a>.</p>
<div class="section" id="monte-carlo-fitting-algorithms">
<span id="custom-mc"></span><h3>8.3.1. Monte Carlo fitting algorithms<a class="headerlink" href="#monte-carlo-fitting-algorithms" title="Permalink to this headline">¶</a></h3>
<p>Unless there is a good reason to do otherwise, Monte Carlo fitting algorithms
should be implemented by subclasses of <tt class="docutils literal"><span class="pre">Sampler</span></tt> to take advantage of the
interactive sampling feature and database backends. Subclasses using the
standard <tt class="docutils literal"><span class="pre">sample()</span></tt> and <tt class="docutils literal"><span class="pre">isample()</span></tt> methods must define one of two methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">draw()</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>If it is possible to generate an independent sample from the posterior at</dt>
<dd>every iteration, the <tt class="docutils literal"><span class="pre">draw</span></tt> method should do so. The default <tt class="docutils literal"><span class="pre">_loop</span></tt>
method can be used in this case.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">_loop()</span></tt>:</dt>
<dd><dl class="first last docutils">
<dt>If it is not possible to implement a <tt class="docutils literal"><span class="pre">draw()</span></tt> method, but you want to</dt>
<dd>take advantage of the interactive sampling option, you should override
<tt class="docutils literal"><span class="pre">_loop()</span></tt>. This method is responsible for generating the posterior
samples and calling <tt class="docutils literal"><span class="pre">tally()</span></tt> when it is appropriate to save the model&#8217;s
state. In addition, <tt class="docutils literal"><span class="pre">_loop</span></tt> should monitor the sampler&#8217;s <tt class="docutils literal"><span class="pre">status</span></tt>
attribute at every iteration and respond appropriately. The possible values
of <tt class="docutils literal"><span class="pre">status</span></tt> are:</dd>
<dt><tt class="docutils literal"><span class="pre">'ready'</span></tt>:</dt>
<dd>Ready to sample.</dd>
<dt><tt class="docutils literal"><span class="pre">'running'</span></tt>:</dt>
<dd>Sampling should continue as normal.</dd>
<dt><tt class="docutils literal"><span class="pre">'halt'</span></tt>:</dt>
<dd>Sampling should halt as soon as possible. <tt class="docutils literal"><span class="pre">_loop</span></tt> should call the
<tt class="docutils literal"><span class="pre">halt()</span></tt> method and return control. <tt class="docutils literal"><span class="pre">_loop</span></tt> can set the status to
<tt class="docutils literal"><span class="pre">'halt'</span></tt> itself if appropriate (eg the database is full or a
<tt class="docutils literal"><span class="pre">KeyboardInterrupt</span></tt> has been caught).</dd>
<dt><tt class="docutils literal"><span class="pre">'paused'</span></tt>:</dt>
<dd>Sampling should pause as soon as possible. <tt class="docutils literal"><span class="pre">_loop</span></tt> should return, but
should be able to pick up where it left off next time it&#8217;s called.</dd>
</dl>
</dd>
</dl>
<p>Samplers may alternatively want to override the default <tt class="docutils literal"><span class="pre">sample()</span></tt> method. In
that case, they should call the <tt class="docutils literal"><span class="pre">tally()</span></tt> method whenever it is appropriate
to save the current model state. Like custom <tt class="docutils literal"><span class="pre">_loop()</span></tt> methods, custom
<tt class="docutils literal"><span class="pre">sample()</span></tt> methods should handle <tt class="docutils literal"><span class="pre">KeyboardInterrupts</span></tt> and call the
<tt class="docutils literal"><span class="pre">halt()</span></tt> method when sampling terminates to finalize the traces.</p>
</div>
</div>
<div class="section" id="a-second-warning-don-t-update-stochastic-variables-values-in-place">
<span id="dont-update-in-place"></span><h2>8.4. A second warning: Don&#8217;t update stochastic variables&#8217; values in-place<a class="headerlink" href="#a-second-warning-don-t-update-stochastic-variables-values-in-place" title="Permalink to this headline">¶</a></h2>
<p>If you&#8217;re going to implement a new step method, fitting algorithm or unusual (non-numeric-valued) <tt class="docutils literal"><span class="pre">Stochastic</span></tt> subclass, you should understand the issues related to in-place updates of <tt class="docutils literal"><span class="pre">Stochastic</span></tt> objects&#8217; values. Fitting methods should never update variables&#8217; values in-place for two reasons:</p>
<ul class="simple">
<li>In algorithms that involve accepting and rejecting proposals, the &#8216;pre-proposal&#8217; value needs to be preserved uncorrupted. It would be possible to make a copy of the pre-proposal value and then allow in-place updates, but in PyMC we have chosen to store the pre-proposal value as <tt class="docutils literal"><span class="pre">Stochastic.last_value</span></tt> and require proposed values to be new objects. In-place updates would corrupt <tt class="docutils literal"><span class="pre">Stochastic.last_value</span></tt>, and this would cause problems.</li>
<li><tt class="docutils literal"><span class="pre">LazyFunction</span></tt>&#8216;s caching scheme checks variables&#8217; current values against its internal cache by reference. That means if you update a variable&#8217;s value in-place, it or its child may miss the update and incorrectly skip recomputing its value or log-probability.</li>
</ul>
<p>However, a <tt class="docutils literal"><span class="pre">Stochastic</span></tt> object&#8217;s value can make in-place updates to itself if the updates don&#8217;t change its identity. For example, the <tt class="docutils literal"><span class="pre">Stochastic</span></tt> subclass <tt class="docutils literal"><span class="pre">gp.GP</span></tt> is valued as a <tt class="docutils literal"><span class="pre">gp.Realization</span></tt> object. GP realizations represent random functions, which are infinite-dimensional stochastic processes, as literally as possible. The strategy they employ is to &#8216;self-discover&#8217; on demand: when they are evaluated, they generate the required value conditional on previous evaluations and then make an internal note of it. This is an in-place update, but it is done to provide the same behavior as a single random function whose value everywhere has been determined since it was created.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/icon.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Extending PyMC</a><ul>
<li><a class="reference internal" href="#nonstandard-stochastics">8.1. Nonstandard Stochastics</a></li>
<li><a class="reference internal" href="#user-defined-step-methods">8.2. User-defined step methods</a><ul>
<li><a class="reference internal" href="#example-an-asymmetric-metropolis-step">8.2.1. Example: an asymmetric Metropolis step</a></li>
<li><a class="reference internal" href="#general-step-methods">8.2.2. General step methods</a></li>
<li><a class="reference internal" href="#metropolis-hastings-step-methods">8.2.3. Metropolis-Hastings step methods</a></li>
<li><a class="reference internal" href="#gibbs-step-methods">8.2.4. Gibbs step methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-fitting-algorithms">8.3. New fitting algorithms</a><ul>
<li><a class="reference internal" href="#monte-carlo-fitting-algorithms">8.3.1. Monte Carlo fitting algorithms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-second-warning-don-t-update-stochastic-variables-values-in-place">8.4. A second warning: Don&#8217;t update stochastic variables&#8217; values in-place</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modelchecking.html"
                        title="previous chapter">7. Model checking and diagnostics</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="distributions.html"
                        title="next chapter">9. Probability distributions</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/extending.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="distributions.html" title="9. Probability distributions"
             >next</a> |</li>
        <li class="right" >
          <a href="modelchecking.html" title="7. Model checking and diagnostics"
             >previous</a> |</li>
        <li><a href="index.html">PyMC 2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Christopher J. Fonnesbeck.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>