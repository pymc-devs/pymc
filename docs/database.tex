

In the examples seen so far, traces are simply held in memory and discarded once
the Python session ends. PyMC provides the means to store these traces on disk,
load them back and add additional samples. Internally, this is implemented in
what we call \emph{database backends}. These backends are simply made of two classes:
\texttt{Database} and \texttt{Trace}, which all present a similar interface to users.
At the moment, PyMC counts seven such backends: \texttt{ram}, \texttt{no{\_}trace},
\texttt{pickle}, \texttt{txt}, \texttt{sqlite}, \texttt{mysql} and \texttt{hdf5}.
In the following, we present the common interface to those backends and a
description of each individual backend.


%___________________________________________________________________________

\hypertarget{accessing-sampled-data}{}
\pdfbookmark[0]{Accessing Sampled Data}{accessing-sampled-data}
\section*{Accessing Sampled Data}
\label{accessing-sampled-data}

To recommended way to access data from an MCMC run, irrespective of the
database backend, is to use the \texttt{trace(self, name, chain=-1)} method:
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~M~=~MCMC(DisasterModel)~\\
>{}>{}>~M.sample(10)~\\
>{}>{}>~M.trace('e'){[}:{]}~\\
array({[}~2.28320992,~~2.28320992,~~2.28320992,~~2.28320992,~~2.28320992,~\\
~~~~~~~~2.36982455,~~2.36982455,~~3.1669422~,~~3.1669422~,~~3.14499489{]})
}\end{quote}

\texttt{M.trace('e')} returns the \texttt{Trace} instance associated with the tallyable
object \titlereference{e}:
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~M.trace('e')~\\
<pymc.database.ram.Trace~object~at~0x7fa4877a8b50>
}\end{quote}

This \texttt{Trace} object from the \texttt{ram} backend has a \texttt{{\_}{\_}getitem{\_}{\_}} method
that is used to access the trace, just as with any other NumPy array.
By default, \texttt{trace} returns the samples from
the last chain (chain=-1), which in this case is equivalent to \texttt{chain=0}. To
return the samples from all the chains, use \texttt{chain=None}:
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~M.sample(5)~\\
>{}>{}>~M.trace('e',~chain=None){[}:{]}~\\
array({[}~2.28320992,~~2.28320992,~~2.28320992,~~2.28320992,~~2.28320992,~\\
~~~~~~~~2.36982455,~~2.36982455,~~3.1669422~,~~3.1669422~,~~3.14499489,~\\
~~~~~~~~3.14499489,~~3.14499489,~~3.14499489,~~2.94672454,~~3.10767686{]})
}\end{quote}


%___________________________________________________________________________

\hypertarget{saving-data-to-disk}{}
\pdfbookmark[0]{Saving Data to Disk}{saving-data-to-disk}
\section*{Saving Data to Disk}
\label{saving-data-to-disk}

By default, the database backend selected by the \texttt{MCMC} sampler is the \texttt{ram}
backend, which simply holds the data in RAM memory. Now, we will create a
sampler that, instead, will write data to a pickle file:
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~M~=~MCMC(DisasterModel,~db='pickle',~dbname='Disaster.pickle')~\\
>{}>{}>~M.db~\\
<pymc.database.pickle.Database~object~at~0x7fa486623d90>~\\
~\\
>{}>{}>~M.sample(10)~\\
>{}>{}>~M.db.commit()
}\end{quote}

Note that in this particular case, no data is written to disk before the call
to \texttt{db.commit}. The \texttt{commit} call creates a file named \titlereference{Disaster.pickle}
that contains the trace of each tallyable object as well as the final state of
the sampler. This means that a user that forgets to call the \texttt{commit}
method runs the risk of losing his data. Some backends write the data to disk
continuously, so that not calling \texttt{commit} is less catastrophic.

In general, however, it is recommended to always call the \texttt{db.close} method
before closing the session. The \texttt{close} method first calls \texttt{commit}, and
goes further in making sure that the database is in a safe state. Once \texttt{close}
has been called, further call to \texttt{sample} will likely fail, at least
for some backends.
\begin{center}\begin{sffamily}
\fbox{\parbox{\admonitionwidth}{
\textbf{\large Warning}
\vspace{2mm}

Users must absolutly call \texttt{close()} before closing the session. Otherwise,
they run the risk of losing their data.
}}
\end{sffamily}
\end{center}

Note that all backends except \texttt{ram} and \texttt{no{\_}trace} take a \texttt{dbname} argument that
specifies the name of the file or directory that will store the data.


%___________________________________________________________________________

\hypertarget{loading-back-a-database}{}
\pdfbookmark[0]{Loading Back a Database}{loading-back-a-database}
\section*{Loading Back a Database}
\label{loading-back-a-database}

To load the file we just created in a new session, use the \texttt{load} function
from the backend that created the database:

\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~import~pymc~\\
>{}>{}>~db~=~pymc.database.pickle.load('Disaster.pickle')~\\
>{}>{}>~len(db.trace('e'){[}:{]})~\\
10
}\end{quote}

The \texttt{db} object also has a \texttt{trace} method identical to that of \texttt{Sampler}.
You can hence inspect the results of a model, even when you don't have the model
around.

To add samples to this file, we need to create an MCMC instance. This time,
instead of setting \texttt{db='pickle'}, we will pass the existing \texttt{Database}:
\begin{quote}{\ttfamily \raggedright \noindent
>{}>{}>~from~pymc.examples~import~DisasterModel~\\
>{}>{}>~M~=~MCMC(DisasterModel,~db=db)~\\
>{}>{}>~M.sample(5)~\\
>{}>{}>~len(M.trace('e',~chain=None){[}:{]})~\\
15~\\
>{}>{}>~M.db.close()
}\end{quote}

%___________________________________________________________________________

\hypertarget{backends-description}{}
\pdfbookmark[0]{Backends Description}{backends-description}
\section*{Backends Description}
\label{backends-description}


%___________________________________________________________________________

\hypertarget{ram}{}
\pdfbookmark[1]{ram}{ram}
\subsection*{ram}
\label{ram}

Used by default, this backend simply holds a copy in memory, with no output written to disk. This is useful for short runs or testing. For long runs generating large amount of data, using this backend may fill the available memory, forcing the OS to store data in the cache, slowing down all applications running on your computer.



%___________________________________________________________________________

\hypertarget{no-trace}{}
\pdfbookmark[1]{no{\_}trace}{no-trace}
\subsection*{no{\_}trace}
\label{no-trace}

This backend simply does not store the trace. This may be useful for testing
purposes.


%___________________________________________________________________________

\hypertarget{txt}{}
\pdfbookmark[1]{txt}{txt}
\subsection*{txt}
\label{txt}

With the \titlereference{txt} backend, the data is written to disk in ASCII files.
More precisely, the \texttt{dbname} argument is used to create a top directory
into which chain directories, called \titlereference{Chain{\_}{\textless}{\#}{\textgreater}}, are going to be created each
time \texttt{sample} is called:
\begin{quote}{\ttfamily \raggedright \noindent
dbname/~\\
~~Chain{\_}0/~\\
~~~~<object~name>.txt~\\
~~~~<object~name>.txt~\\
~~~~...~\\
~~Chain{\_}1/~\\
~~~~<object~name>.txt~\\
~~~~<object~name>.txt~\\
~~~~...~\\
~~...
}\end{quote}

In each one of these chain directories, files named \texttt{<variable name>.txt}
are created, storing the values of the variable as rows of text:
\begin{quote}{\ttfamily \raggedright \noindent
{\#}~Variable:~e~\\
{\#}~Sample~shape:~(5,)~\\
{\#}~Date:~2008-11-18~17:19:13.554188~\\
3.033672373807017486e+00~\\
3.033672373807017486e+00~\\
...
}\end{quote}

Although this backend makes it easy to load the data using another application,
for large datasets files tend to be embarassingly large and slow to load
into memory.


%___________________________________________________________________________

\hypertarget{pickle}{}
\pdfbookmark[1]{pickle}{pickle}
\subsection*{pickle}
\label{pickle}

As its name implies, the \titlereference{pickle} database relies on the \titlereference{Cpickle} module to save the trace objects. Use of this backend is appropriate for small scale, short-lived projects. For longer term or larger projects, the \titlereference{pickle} backend should be avoided since generated files might be unreadable across different Python versions.


%___________________________________________________________________________

\hypertarget{hdf5}{}
\pdfbookmark[1]{hdf5}{hdf5}
\subsection*{hdf5}
\label{hdf5}

The hdf5 backend uses \href{http://www.pytables.org/moin}{pyTables} to save data in binary HDF5 format. The main advantage of this backend is that data is flushed regularly to disk, reducing memory usage and allowing sampling of datasets much larger than the available RAM memory, speeding up data access. For this backend to work, pyTables must be installed, which in turn requires the \titlereference{hdf5} library.


%___________________________________________________________________________

\hypertarget{sqlite}{}
\pdfbookmark[1]{sqlite}{sqlite}
\subsection*{sqlite}
\label{sqlite}

The sqlite backend stores trace objects using the \href{http://www.sqlite.org/}{SQLite} database engine. SQLite is a small C library that implements a self-contained relational database, which makes it popular for embedding in applications. Unlike traditional relational database management systems, it needs no configuration or special dependencies. In fact, SQLite is built in to Python 2.5 and can be accessed using the sqlite3 module. PyMC can exploit this facility to store traces, and is well-suited to storing large quantity of output. The resulting database file (named with a \titlereference{.sqlite} siuffix) can be opened by SQLite, or any applications that interface with SQLite.


%___________________________________________________________________________

\hypertarget{mysql}{}
\pdfbookmark[1]{mysql}{mysql}
\subsection*{mysql}
\label{mysql}

The mysql backend stores trace objects in the \href{http://www.mysql.com/}{MySQL} relational database management system. MySQL is an open-source, networked database that can be installed on a variety of platforms and is suitable for storing very large quantities of data. Unlike SQLite, however, MySQL requires some configuration before it can be used by PyMC. A database on the SQLite server must be set up beforehand, and the appropriate permissions granted to the user (in particular, the ability to create and delete tables). The user must provide to the backend the name of the database, their user ID and password, and the host and port of the server, if it is networked.

\leavevmode
\begin{longtable}[c]{|p{0.133\locallinewidth}|p{0.447\locallinewidth}|p{0.307\locallinewidth}|}
\hline
\textbf{
Backend
} & \textbf{
Description
} & \textbf{
External Dependencies
} \\
\hline
\endhead

no{\_}trace
 & 
Do not tally samples at all.
 &  \\
\hline

ram
 & 
Store samples in live memory.
 &  \\
\hline

txt
 & 
Write data to ascii files.
 &  \\
\hline

pickle
 & 
Write data to a pickle file.
 &  \\
\hline

hdf5
 & 
Store samples in the HDF5 format.
 & 
pytables ({\textgreater}2.0), libhdf5
 \\
\hline

sqlite
 & 
Store samples in a sqlite database.
 & 
sqlite3
 \\
\hline

mysql
 & 
Store samples in a mysql database.
 & 
MySQLdb
 \\
\hline
\end{longtable}

For more information about individual backends, refer to the \href{docs/API.pdf}{API} documentation.

